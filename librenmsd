#!/usr/bin/env php
<?php
/* Copyright (C) 2015 Daniel Preussker, QuxLabs UG <preussker@quxlabs.com>
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/**
 * Daemon
 * @author Daniel Preussker <preussker@quxlabs.com>
 * @copyright 2015 Daniel Preussker, QuxLabs UG
 * @license GPL
 * @package LibreNMS
 * @subpackage Daemon
 */

// IMPORTANT: Please set this!
$BASEDIR="/opt/librenms";

/* LSB metadata
### BEGIN INIT INFO
# Provides:          librenms
# Required-Start:    $remote_fs $network
# Required-Stop:     $remote_fs $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: starts LibreNMS-Daemon
# Description:       Starts the LibreNMS Daemon to poll and discover devices or services, issue alerts and account bills
### END INIT INFO
*/

/* Red Hat chkconfig metadata
# chkconfig: 2345 90 90
# description: Starts the LibreNMS Daemon to poll and discover devices or services, issue alerts and account bills
*/

set_time_limit(0);
ini_set('max_execution_time',0);
declare(ticks=1);
pcntl_signal(SIGCHLD, 'cleanup');
register_shutdown_function('catchFatal');
chdir($BASEDIR);
define('IS_DAEMON',true);

// Load config
$cfiles = array("includes/defaults.inc.php","config.php","includes/definitions.inc.php");
$chash  = "";
require_once 'includes/defaults.inc.php';
require_once 'config.php';
require_once 'includes/definitions.inc.php';
require_once 'includes/functions.php';
$config = loadcnf();

if( $config['daemon']['pm'] == "fcgi" ){
	require_once 'lib/fastcgi-client/src/Adoy/FastCGI/Client.php';
}
if( $_SERVER['SPAWN_JOB'] == "/spawn" ) {
	if( !empty($_SERVER['REQUEST_URI']) ) {
		spawn(unserialize($_SERVER['REQUEST_URI']));
	} else {
		var_dump('PONG');
	}
	$code = 0;
} else {
	//Be an initscript
	$code = 2;
	if( $argc > 1 ) {
		switch( $argv[1] ) {
			case "foreground":
				goto main;
			break;
			case "start":
				$code = start();
				if( $code === 2 ) {
					goto main;
				} else {
					$code = (int) !$code;
				}
			break;
			case "stop":
				$code = (int) !stop();
			break;
			case "status":
				$code = (int) !status();
			break;
			case "restart":
				stop();
				$code = start();
				if( $code === 2 ) {
					goto main;
				} else {
					$code = (int) !$code;
				}
			break;
			default:
				echo "Unknown '".$argv[1]."'\r\n";
			break;
		}
	} else {
		echo 'Usage: '.$argv[0].' start|stop|restart|status|foreground'."\r\n";
	}
}
exit($code);

/**
 * Start Process
 * @return boolean|int
 */
function start() {
	global $config;
	if( status() === false ) {
		if( !posix_setuid($config['daemon']['uid']) || !posix_seteuid($config['daemon']['uid']) ) {
			echo 'Could not set UID '.$config['daemon']['uid']."\r\n";
			return false;
		}
		$pid = fork();
		if( $pid === true ) {
			return 2;
		} elseif( $pid > 0 ) {
			if( !file_put_contents($config['install_dir'].'/librenmsd.pid',$pid,LOCK_EX) ) {
				echo 'WARNING: Could to write to PID file "'.$config['install_dir'].'/librenmsd.pid"!'."\r\n";
			}
			echo 'Started LibreNMS-Daemon with PID: '.$pid."\r\n";
			return true;
		} else {
			echo 'Could not start LibreNMS-Daemon.'."\r\n";
		}
	}
	return false;
}

/**
 * Stop Process
 * @return boolean
 */
function stop() {
	global $config;
	if( status() === true ) {
		$pid = trim(file_get_contents($config['install_dir'].'/librenmsd.pid'));
		if( posix_kill($pid, SIGKILL) && (sleep(2) !== false && !status()) ) {
			echo 'Stopped LibreNMS-Daemon'."\r\n";
			return true;
		} else {
			echo 'Could not stop LibreNMS-Daemon, Kill manually PID: '.$pid."\r\n";
		}
	}
	return false;
}

/**
 * Process Status
 * @return boolean
 */
function status() {
	global $config;
	if( file_exists($config['install_dir'].'/librenmsd.pid') ) {
		$pid = trim(file_get_contents($config['install_dir'].'/librenmsd.pid'));
		if( file_exists('/proc/'.$pid.'/stat') ) {
				$status = explode("\x00",file_get_contents('/proc/'.$pid.'/cmdline'));
				if( !stristr($status[1],'librenmsd') ) {
					unlink($config['install_dir'].'/librenmsd.pid');
				} else {
					echo 'LibreNMS-Daemon is running ('.$pid.').'."\r\n";
					return true;
				}
		} else {
			unlink($config['install_dir'].'/librenmsd.pid');
		}
	}
	echo 'LibreNMS-Daemon is not running'."\r\n";
	return false;
}

/**
 * Connect to MySQL
 * @return void
 */
function mysql_wrap() {
	global $config, $database_link, $database_db;
	if( is_resource($database_link) ) {
		mysql_close($database_link);
		logger("Closed MySQL-Connection",LOG_DEBUG,'mysql');
	}
	$database_link = mysql_pconnect($config['db_host'], $config['db_user'], $config['db_pass'],true);
	if (!$database_link) {
		logger("Could not connect to MySQL: ".mysql_error(),LOG_ALERT,'mysql');
	}
	$database_db = mysql_select_db($config['db_name'], $database_link);
	logger("Opened MySQL-Connection",LOG_DEBUG,'mysql');
}

/**
 * (Re)syunc Clocks
 * @return void
 */
function clocksync() {
	global $step, $ts, $i;
	$ts = time() - ( time() % $step );
	$i  = (($ts%86400)/$step);
	logger("Clock sync'd",LOG_INFO,'clock');
}

/**
 * (Re)load config
 * @return array
 */
function loadcnf() {
	global $config, $cfiles, $chash, $BASEDIR;
	$data = "";
	foreach( $cfiles as $file ) {
		$data .= file_get_contents($BASEDIR.'/'.$file);
	}
	$hash = sha1($data);
	if( $hash != $chash ) {
		$chash = $hash;
		unset($config);
		eval(str_ireplace(array('<?php','?>'),'',$data));
		logger("Config now at ".$chash,LOG_DEBUG,'main');
	}
	return $config;
}

/**
 * Sleep until timestamp
 * @param float $ts Microtime-Target
 * @return boolean
 */
function sleep_until($ts) {
	while( ($delta=($ts-microtime(true))) > 0 ) {
		usleep(($delta/2)*1000000);
	}
	return true;
}

/**
 * Fork-wrapper
 * @return int|boolean
 */
function fork() {
	$pid = pcntl_fork();
	if( $pid == -1 ) {
		return false;
	} elseif( $pid ) {
		return $pid;
	} else {
		return true;
	}
}

/**
 * Log messages
 * @param string|array $msgs Message/s
 * @param int $lvl Log-Level
 * @param string $prefix Log-Prefix
 * @return void
 */
function logger($msgs,$lvl=LOG_INFO,$prefix='') {
	global $config;
	if( $lvl === LOG_DEBUG && ($config['daemon']['debug'] === false || ($config['daemon']['debug'] !== true && stripos($config['daemon']['debug'],$prefix) === false) ) ) {
		return;
	}
	openlog('librenms', (LOG_CONS | LOG_NDELAY | LOG_PID), (isset($config['daemon']['facility']) ? $config['daemon']['facility'] : LOG_DAEMON));
	if( !is_array($msgs) ) {
		$msgs = explode("\n",$msgs);
	}
	foreach( $msgs as $msg ) {
		if( !empty($msg) ) {
			if( !empty($prefix) ) {
				$msg = '['.strtoupper($prefix).'] '.$msg;
			}
			syslog($lvl,$msg);
		}
	}
	closelog();
}

/**
 * Spawn a job as fork
 * @param array $job Job-Object
 * @return int
 */
function spawn($job) {
	global $config, $jobs, $db_stats, $rrd_pipes, $debug;
	if( !is_array($job) || !isset($job['type']) ){
		return -127;
	}
	if( $config['daemon']['pm'] == "builtin" || !isset($_SERVER['REQUEST_URI'])) {
		$pid = fork();
	}
	if( $config['daemon']['pm'] == "fcgi" && $job['type'] != 'internal' ) {
		if( unserialize($_SERVER['REQUEST_URI']) != $job) {
			if( $pid === true ) {
				logger("'".($job['file'] ? $job['file'] : $job['func']).($job['args'] ? ' '.(is_array($job['args']) ? json_encode($job['args']) : $job['args']) : '')."' => FCGI",LOG_DEBUG,'jobctl');
				$pm = new Adoy\FastCGI\Client($config['daemon']['fcgi']['host'], $config['daemon']['fcgi']['port']);
				$pm->setPersistentSocket(true);
				$pm->setReadWriteTimeout(86400000);
				$pm->setConnectTimeout(86400000);
				logger($pm->request(array(
					'DOCUMENT_ROOT'     => $config['install_dir'],
					'REMOTE_ADDR'       => '127.0.0.1',
					'REMOTE_PORT'       => '8801',
					'SERVER_ADDR'       => '127.0.0.1',
					'SERVER_PORT'       => '8801',
					'SERVER_NAME'       => 'localhost',
					'SERVER_SOFTWARE'   => 'LibreNMSd',
					'GATEWAY_INTERFACE' => 'FastCGI/1.0',
					'SERVER_PROTOCOL'   => 'HTTP/1.1',
					'REQUEST_METHOD'    => 'GET',
					'QUERY_STRING'      => '',
					'SCRIPT_FILENAME'   => $config['install_dir'].'/daemon.php',
					'SCRIPT_NAME'       => '/daemon.php',
					'SPAWN_JOB'         => '/spawn',
					'REQUEST_URI'       => serialize($job))),LOG_DEBUG,'jobctl/fcgi');
				logger("'".($job['file'] ? $job['file'] : $job['func']).($job['args'] ? ' '.(is_array($job['args']) ? json_encode($job['args']) : $job['args']) : '')."' <= FCGI",LOG_DEBUG,'jobctl');
				unset($pm);
				exit(0);
			}
		} else {
			$pid = true;
		}
	}
	if( $pid === true ) {
		$job['file'] = $config['install_dir'].'/'.$job['file'];
		$code = 0;
		$out = '';
		if( $job['type'] == 'exec' ) {
			$out  = explode("\n",shell_exec($job['file'].' '.$job['args'].' 2>&1 || echo -n $?'));
			$code = (int) array_pop($out);
		} elseif( $job['type'] == 'include' ) {
			if( !file_exists($job['file']) ) {
				$out = 'File not found: '.$job['file'];
				$code = 127;
			} else {
				pcntl_signal(SIGCHLD, SIG_DFL);
				ob_start();
				mysql_wrap();
				$argv = array($job['file']);
				$options = $job['args'];
				{ include($job['file']); }
				$out = ob_get_clean();
			}
		} elseif( $job['type'] == 'internal' ) {
			ob_start();
			eval('daemon__'.$job['func'].'($job["args"]);');
			$out = ob_get_clean();
		}
		logger($out,LOG_DEBUG,'jobctl');
		exit($code);
	} elseif( $pid > 0 ) {
		if( is_array($job['args']) ) {
			$job['args'] = json_encode($job['args']);
		}
		$job = ($job['file'] ? $job['file'] : $job['func']).($job['args'] ? ' '.$job['args'] : '');
		$jobs[$pid] = $job;
		logger("'".$job."' / '".$pid."' - Spawned",LOG_DEBUG,'jobctl');
		return $pid;
	}
}

/**
 * Poll Device
 * @param array $options Arguments
 * @return void
 */
function daemon__poller($options) {
	global $config, $jobs;
	logger("Poller Starting",LOG_INFO,'poller');
	require_once "includes/functions.php";
	require_once "includes/polling/functions.inc.php";
	require_once "includes/alerts.inc.php";
	if( !isset($options['threads']) ) {
		$options['threads'] = 16;
	} elseif( $options['threads'] == 'auto' ) {
		$autoscale = true;
		if( empty($options['max']) ) {
			$options['max'] = 16;
		}
		if( empty($options['min']) ) {
			$options['min'] = 2;
		}
		if( empty($options['thresh']) ) {
			$options['thresh'] = 1;
		}
		if( empty($options['target']) ) {
			$options['target'] = 240;
		}
	}
	$sql_params = array();
	if( $config['distributed_poller'] == true ) {
		$sql = "select device_id from devices where poller_group IN(?) and disabled = 0 order by last_polled_timetaken desc";
		$sql_params[] = $config['distributed_poller_group'];
	} else {
		$sql = "select device_id from devices where disabled = 0 order by last_polled_timetaken desc";
	}
	$pids = array();
	logger("SQL: $sql",LOG_DEBUG,'poller');
	mysql_wrap();
	if( $autoscale ) {
		$devices = dbFetchRow("select ceil(sum(last_polled_timetaken)) as a,avg(last_polled_timetaken) as q,count(device_id) as c,ceil(sum(last_polled_timetaken) / ".((int) ($options['target']))." + 1) as d from devices where disabled = 0");
		$options['threads'] = (int) ceil($devices['d']);
		if( $options['max'] < $options['threads'] ) {
			$options['threads'] = $options['max'];
		} elseif( $options['min'] > $options['threads'] ) {
			$options['threads'] = $options['min'];
		}
		logger("Setting Threads: ".$options['threads'],LOG_INFO,'poller');
		$init = time();
	}
	$x = 0;
	foreach( dbFetchRows($sql,$sql_params) as $device ) {
		while( sizeof($pids) >= $options['threads'] ) {
			usleep(200000);
			cleanup();
			$pids = array_intersect($pids,array_keys($jobs));
			if( $autoscale ) {
				if( $x <= $options['threads'] ) {
					continue;
				} else {
					$z = $x - $options['threads'];
				}
				$d = (time()-$init)*$options['threads'];
				if( $d <= $devices['a'] ) {
					$r = $devices['a']-($z * $devices['q'])+$d;
				} else {
					$r = $d;
				}
				$t = (int) ceil($r / $options['target'] + 1);
				if( $options['max'] < $t ) {
					$t = $options['max'];
				} elseif( $options['min'] > $t ) {
					$t = $options['min'];
				}
				if( $t != $options['threads'] && (( $t > $options['threads'] && ( $t - $options['threads'] >= $options['thresh'] ) ) || ($t < $options['threads'] && ( $options['threads'] - $t >= $options['thresh']*1.5 ) ) )) {
					$options['threads'] = $t;
					logger("Modify Threads: ".$options['threads'],LOG_INFO,'poller');
				}
			}
		}
		logger("ID: ".$device['device_id'],LOG_DEBUG,'poller');
		$pid = spawn(array('type'=>'include','file'=>'poller.php','args'=>array('h'=>$device['device_id'])));
		if( is_numeric($pid) ) {
			$pids[] = $pid;
		}
		if( (++$x)%100 == 0 ) {
			logger("Polled ".$x." devices so far...",LOG_INFO,'poller');
		}
	}
	$pids = array_intersect($pids,array_keys($jobs));
	while( sizeof($pids) >= 1 ) {
		usleep(200000);
		cleanup();
		$pids = array_intersect($pids,array_keys($jobs));
	}
	cleanup();
	logger("Poller Finished",LOG_INFO,'poller');
}

/**
 * Discover Devices
 * @param array $options Arguments
 * @return void
 */
function daemon__discovery($options) {
	global $config, $jobs;
	require_once "includes/functions.php";
	require_once "includes/discovery/functions.inc.php";
	if( !isset($options['threads']) ) {
		$options['threads'] = 16;
	}
	$sql_params = array();
	if( isset($options['new']) ) {
		$extra = 'AND `last_discovered` IS NULL';
	} else {
		$extra = '';
	}
	if( $config['distributed_poller'] == true ) {
		$sql = "select device_id from devices where poller_group IN(?) and disabled = 0 $extra order by last_polled_timetaken desc";
		$sql_params[] = $config['distributed_poller_group'];
	} else {
		$sql = "select device_id from devices where disabled = 0 $extra order by last_polled_timetaken desc";
	}
	$pids = array();
	logger("SQL: $sql",LOG_DEBUG,'discovery');
	mysql_wrap();
	foreach( dbFetchRows($sql,$sql_params) as $device ) {
		while( sizeof($pids) >= $options['threads'] ) {
			$pids = array_intersect($pids,array_keys($jobs));
			usleep(200000);
			cleanup();
		}
		logger("ID: ".$device['device_id'],LOG_DEBUG,'discovery');
		$pid = spawn(array('type'=>'include','file'=>'discovery.php','args'=>array('h'=>$device['device_id'])));
		if( is_numeric($pid) ) {
			$pids[] = $pid;
		}
	}
	$pids = array_intersect($pids,array_keys($jobs));
	while( sizeof($pids) >= 1 ) {
		$pids = array_intersect($pids,array_keys($jobs));
		usleep(200000);
		cleanup();
	}
	cleanup();
}

/**
 * Log fatals to syslog
 */
function catchFatal() {
	$last_error = error_get_last();
	if ($last_error['type'] == 1) {
		$log_error = array($last_error['type'],$last_error['message'],$last_error['file'],$last_error['line']);
		logger($last_error['file'].'#'.$last_error['line'].': '.$last_error['message'],LOG_EMERG,'main');
	}
}

/**
 * Cleanup Zombies
 * @param int $sig Signal
 * @param int $pid PID defaults to -1
 * @param int $status Exit-Status
 * @return void
 */
function cleanup($sig, $pid=-1, $status=null) {
	global $jobs;
	while( ($pid=pcntl_waitpid($pid, $status, WNOHANG)) > 0 ) {
		$status = pcntl_wexitstatus($status);
		logger("'".($jobs[$pid] ? $jobs[$pid] : 'UNKOWN!')."' / '".$pid."' - Terminated, Status: ".$status,LOG_DEBUG,'jobctl');
		unset($jobs[$pid]);
	}
}

/**
 * Main-loop
 */
main: {
	$step      = 10;
	$ts        = 0;
	$i         = 0;
	$jobs      = array();
	$db_stats  = array();
	$rrd_pipes = array();
	$debug     = false;
	clocksync();

	logger('Initialized',LOG_INFO,'main');
	$sync = false;
	do {
		if( $sync === true && $i == 3 ) {
			// Resync-Clock at interval 3
			clocksync();
			$sync = false;
		 }

		$ts += $step;
		logger('Interval #'.$i,LOG_DEBUG,'clock');

		// Update config-cache
		$config = loadcnf();

		// Cycle through daemons
		foreach( $config['daemon']['intervals'] as $f => $d ) {
			if( ($i*$step)%$f == 0 ) {
				foreach( $d as $int => $run ) {
					if( (($i*$step)/$f)%$int == 0 ) {
						foreach( $run as $job ) {
							logger('Triggered Job: '.json_encode($job),LOG_INFO,'main');
							spawn($job);
						}
					}
				}
			}
		}

		if( $i == 8639 ) {
			// Overflow at interval 8639
			$i = 0;
			$sync = true;
		} else {
			$i++;
		}

		} while( sleep_until($ts) === true );
		exit(0);
}
